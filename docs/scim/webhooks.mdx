# Best Practices for Webhooks

Webhooks are HTTP endpoints that you register with a system, allowing that system to inform your
application about events by sending HTTP POST requests with event information in the body.

Developers register their applications' webhook endpoints with Scalekit to listen to events from the
directory providers of their enterprise customers. Here are some common best practices developers
follow to ensure their apps are secure and performant:

## Subscribe to the Minimum Number of Events

While you can listen to all events from Scalekit, it's best to subscribe only to the events your app
needs. This approach has several benefits:

- Your app doesn't have to process every event
- You can avoid overloading a single execution context by handling every event type

## Verify Webhook Signatures

Scalekit sends POST requests to your registered webhook endpoint. To ensure the request is coming
from Scalekit and not a malicious actor, you should verify the request using the Signing Secret
found in the Scalekit Dashboard > Webhook > _Any Endpoint_.

Here's an example of how to verify webhooks using the Svix library:

<CodeWithHeader title="Webhook Signature Verification">
<Tabs>

<TabItem label="Next.js" value="Next">

```javascript
export async function POST(req: NextRequest) {
  // Parse the JSON body of the request
  const event = await req.json();

  // Get headers from the request
  const headers = req.headers;

  // Secret from Scalekit Dasbhoard > Webhooks
  const secret = process.env.SCALEKIT_WEBHOOK_SECRET;

  try {
    // Verify the webhook payload using the secret, headers, and event data
    await scalekit.verifyWebhookPayload(secret, headers, event);
  } catch (error) {
    // Return a 400 response if the signature is invalid
    return NextResponse.json({ error: 'Invalid signature' }, { status: 400 });
  }
}
```

</TabItem>

<TabItem label="Python" value="Python">

```python
from svix.webhooks import Webhook

secret = "<WEBHOOK_SIGNING_SECRET>"

# These were all sent from the server
headers = {
  "svix-id": "msg_p5jXN8AQM9LWM0D4loKWxJek",
  "svix-timestamp": "1614265330",
  "svix-signature": "v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE=",
}
payload = '{"event": "directory_payload"}'

wh = Webhook(secret)
# Throws on error, returns the verified content on success
payload = wh.verify(payload, headers)
```

</TabItem>

<TabItem label="Go" value="Go">

```go
import (
    svix "github.com/svix/svix-webhooks/go"
)

secret := "whsec_MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw"

// These were all sent from the server
headers := http.Header{}
headers.Set("svix-id", "msg_p5jXN8AQM9LWM0D4loKWxJek")
headers.Set("svix-timestamp", "1614265330")
headers.Set("svix-signature", "v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE=")

payload := []byte(`{"test": 2432232314}`)

wh, err := svix.NewWebhook(secret)
err := wh.Verify(payload, headers)
// returns nil on success, error otherwise
```

</TabItem>

<TabItem label="Java" value="Java">

```java
import com.svix.Webhook;

String secret = "whsec_MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw";

// These were all sent from the server
HashMap<String, List<String>> headerMap = new HashMap<String, List<String>>();
headerMap.put("svix-id", Arrays.asList("msg_p5jXN8AQM9LWM0D4loKWxJek"));
headerMap.put("svix-timestamp", Arrays.asList("1614265330"));
headerMap.put("svix-signature", Arrays.asList("v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE="));
HttpHeaders headers = HttpHeaders.of(headerMap, BiPredicate<String, String>)

String payload = "{\"test\": 2432232314}";

Webhook webhook = new Webhook(secret);

webhook.verify(payload, headers)
// throws WebhookVerificationError exception on failure.

```

</TabItem>

</Tabs>
</CodeWithHeader>

## Check the Event Type Before Processing

Make sure to check the event.type before consuming the data received by the webhook endpoint. This
ensures that your application relies on accurate information, even if more events are added in the
future.

<CodeWithHeader title="">

<Tabs>

<TabItem label="Next.js" value="Next">

```javascript
export async function POST(req: NextRequest) {
  const event = await req.json();

  if (event.type == "scalekit.dir.user.create") {
    const { email, name } = event.data;
    await createUserAccount(email, name);
  }

  return NextResponse.json({ status: 201 });
}
```

</TabItem>

</Tabs>
</CodeWithHeader>

## Redeliver Missed Events

If your app experiences downtime and misses events sent by Scalekit, you can redeliver those events
from the Scalekit Dashboard:

1. Navigate to Webhooks
2. Click the three dots and select "Replay"
3. Choose "Resent all failed message since" to resend all messages your app failed to acknowledge
   during its downtime

## Avoid Webhook Timeouts

To avoid unnecessary timeouts, respond to the webhook trigger with a response code of 201 and
process the event asynchronously.

By following these best practices, you can ensure that your application effectively handles events
from Scalekit, maintaining optimal performance and security.
